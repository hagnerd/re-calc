// Generated by BUCKLESCRIPT VERSION 5.0.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var CalcParse$ReCalc = require("./CalcParse.bs.js");

function operate_f(operator, n1, n2) {
  switch (operator) {
    case "*" : 
        return /* Ok */Block.__(0, [n1 * n2]);
    case "+" : 
        return /* Ok */Block.__(0, [n1 + n2]);
    case "-" : 
        return /* Ok */Block.__(0, [n1 - n2]);
    case "/" : 
        if (n2 === 0.0) {
          return /* Err */Block.__(1, ["Cannot divide by zero"]);
        } else {
          return /* Ok */Block.__(0, [n1 / n2]);
        }
    default:
      return /* Err */Block.__(1, ["Cannot divid by zero"]);
  }
}

function calc_once(input, regex) {
  var match = Curry._1(regex, input);
  var n2 = match[2];
  var n1 = match[1];
  var operator = match[0];
  var toReplace = CalcParse$ReCalc.construct_replacer(operator, n1, n2);
  var result = operate_f(operator, Caml_format.caml_float_of_string(n1), Caml_format.caml_float_of_string(n2));
  if (result.tag) {
    return /* Err */Block.__(1, [result[0]]);
  } else {
    var res = CalcParse$ReCalc.format_result(result[0]);
    var new_input = input.replace(toReplace, res);
    return /* Ok */Block.__(0, [new_input]);
  }
}

function calculate(_input) {
  while(true) {
    var input = _input;
    if (input.tag) {
      return /* Err */Block.__(1, [input[0]]);
    } else {
      var input$1 = input[0];
      if (CalcParse$ReCalc.has_operator(input$1) && CalcParse$ReCalc.has_mult_or_div(input$1)) {
        var res = calc_once(input$1, CalcParse$ReCalc.get_first_mult_or_div);
        if (res.tag) {
          _input = /* Err */Block.__(1, [res[0]]);
          continue ;
        } else {
          _input = /* Ok */Block.__(0, [res[0]]);
          continue ;
        }
      } else if (CalcParse$ReCalc.has_operator(input$1) && CalcParse$ReCalc.has_add_or_sub(input$1)) {
        var res$1 = calc_once(input$1, CalcParse$ReCalc.get_first_add_or_sub);
        if (res$1.tag) {
          _input = /* Err */Block.__(1, [res$1[0]]);
          continue ;
        } else {
          _input = /* Ok */Block.__(0, [res$1[0]]);
          continue ;
        }
      } else {
        return /* Ok */Block.__(0, [input$1]);
      }
    }
  };
}

exports.operate_f = operate_f;
exports.calculate = calculate;
exports.calc_once = calc_once;
/* CalcParse-ReCalc Not a pure module */
